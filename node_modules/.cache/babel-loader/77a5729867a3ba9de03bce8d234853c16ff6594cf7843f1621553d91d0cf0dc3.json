{"ast":null,"code":"var _jsxFileName = \"E:\\\\projects\\\\longmeet-lets-thango-main\\\\src\\\\components\\\\Room\\\\Room.tsx\",\n  _s = $RefreshSig$();\nimport * as React from 'react';\nimport { db, analytics } from '../../libs';\nimport { config } from '../../shared';\nimport './Room.css';\nimport { CustomizedAlert } from '../';\nimport { ActionButtons } from './ActionButtons';\nimport { Video } from './Video';\nimport { useHistory, useLocation } from 'react-router';\nimport VolumeOffSharpIcon from '@material-ui/icons/VolumeOffSharp';\nimport VolumeUpSharpIcon from '@material-ui/icons/VolumeUpSharp';\nimport VideocamSharpIcon from '@material-ui/icons/VideocamSharp';\nimport VideocamOffSharpIcon from '@material-ui/icons/VideocamOffSharp';\nimport Tooltip from '@material-ui/core/Tooltip';\nimport Fab from '@material-ui/core/Fab';\nimport { ConnectType, ALERT_TYPE, CALL_TYPE } from '../../interfaces';\nimport { useAlert } from '../../hooks';\nimport * as ROUTES from '../../routes';\nimport { logger } from '../../utils';\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nimport { Fragment as _Fragment } from \"react/jsx-dev-runtime\";\nconst {\n  useRef,\n  useEffect,\n  useState\n} = React;\nexport const Room = () => {\n  _s();\n  const clipboardRef = useRef(null);\n  const localVideo = useRef(null);\n  const shareVideo = useRef(null);\n  const shareContainer = useRef(null);\n  const videoContainer = useRef(null);\n  const session = useRef({});\n  const globalListeners = useRef([]);\n  const localStream = useRef(new MediaStream());\n  const shareStream = useRef(new MediaStream());\n  const callID = useRef('');\n  const callType = useRef(CALL_TYPE.video);\n  const user = useRef('');\n  const userName = useRef('');\n  const location = useLocation();\n  const history = useHistory();\n  const {\n    openAlert,\n    setAlertMessage,\n    setOpenAlert,\n    alertMessage,\n    alertType,\n    fireAlert\n  } = useAlert();\n  const [sessionState, setSessionState] = useState({});\n  const [mute, setMute] = useState(false);\n  const [webcam, setWebcam] = useState(false);\n  const [isSharing, setIsSharing] = useState(false);\n  const addToSession = (key, peer) => {\n    if (session.current[key]) {\n      logger(`Duplicate key ${key}`);\n      deleteSessionByKey(key);\n      addToSession(key, peer);\n    } else {\n      session.current[key] = peer;\n      setSessionState(currentSession => {\n        return {\n          ...currentSession,\n          [key]: peer\n        };\n      });\n    }\n    logger(session.current);\n  };\n  const deleteSessionByKey = key => {\n    if (session.current[key]) {\n      logger(`Deleting ${key}`);\n      session.current[key].pc.close();\n      session.current[key].listeners.forEach(listener => listener());\n      delete session.current[key];\n      setSessionState(session.current);\n    } else {\n      logger(`${key} does not exist.`);\n    }\n  };\n  useEffect(() => {\n    // Interval to update videos\n    // const interval = setInterval(sessionCallback, 1000);\n\n    const main = async () => {\n      try {\n        if (!location.state) {\n          fireAlert('Invalid State. Please join or create call via the appropriate screen.', ALERT_TYPE.error);\n          setTimeout(() => {\n            handleEndCall();\n          }, 1500);\n        } else {\n          const state = location.state;\n          callID.current = state.callID;\n          user.current = state.userID;\n          userName.current = state.name;\n          callType.current = state.callType;\n          switch (state.action) {\n            case 'call':\n              {\n                await handleWebcam(callType.current);\n                await handleCall();\n                break;\n              }\n            case 'answer':\n              {\n                await handleWebcam(callType.current);\n                await handleAnswer();\n              }\n          }\n\n          // If it's a reload, nuke state\n          history.replace({\n            pathname: ROUTES.ROOM,\n            state: undefined\n          });\n        }\n      } catch (error) {\n        logger(error);\n        setAlertMessage('Call Failed. Please exit and create a new call.');\n        setOpenAlert(true);\n      }\n    };\n    main();\n    return () => {\n      // clearInterval(interval);\n      // Undo as many listeners as possibe\n      // eslint-disable-next-line\n      Object.keys(session.current).forEach(key => {\n        // peer.listeners.forEach((listener) => listener());\n        deleteSessionByKey(key);\n      });\n      // eslint-disable-next-line\n      globalListeners.current.forEach(listener => listener());\n    };\n    // eslint-disable-next-line\n  }, []);\n  const createOfferPeer = async (call, userID, peerID, name, stream, type = ConnectType.user) => {\n    const sessionKey = type === ConnectType.user ? peerID : `share_to_offer_${peerID}`;\n    if (!session.current[sessionKey]) {\n      // Socket Connections\n      const callDoc = db.collection('calls').doc(call);\n      const userDoc = callDoc.collection('users').doc(userID);\n      const offers = userDoc.collection('offers').doc(peerID);\n      const answers = userDoc.collection('answers').doc(peerID);\n      const offerCandidates = userDoc.collection('offerCandidates').doc(peerID).collection('candidates');\n      const answerCandidates = userDoc.collection('answerCandidates').doc(peerID).collection('candidates');\n      const peer = {\n        name,\n        peerID: sessionKey,\n        pc: new RTCPeerConnection(config.servers),\n        remoteStream: new MediaStream(),\n        listeners: [],\n        type\n      };\n\n      // Push tracks from local stream to peer connection\n      stream.getTracks().forEach(track => {\n        peer.pc.addTrack(track, stream);\n      });\n      peer.pc.ontrack = e => {\n        e.streams.forEach(stream => {\n          stream.getTracks().forEach(track => {\n            peer.remoteStream.addTrack(track);\n          });\n        });\n      };\n\n      // Handle disconnect\n      peer.pc.onconnectionstatechange = e => {\n        switch (peer.pc.connectionState) {\n          case \"disconnected\":\n            {\n              deletePeerConnection(sessionKey, peer);\n              break;\n            }\n          case \"closed\":\n            {\n              deletePeerConnection(sessionKey, peer);\n              break;\n            }\n          case \"failed\":\n            {\n              deletePeerConnection(sessionKey, peer);\n              break;\n            }\n        }\n      };\n\n      // Handle Ice Candidate\n      peer.pc.onicecandidate = e => {\n        e.candidate && offerCandidates.add(e.candidate.toJSON());\n      };\n      const offerDescription = await peer.pc.createOffer();\n      await peer.pc.setLocalDescription(offerDescription);\n      const offer = {\n        sdp: offerDescription.sdp,\n        type: offerDescription.type\n      };\n      // Push offer to user's specific record\n      await offers.set({\n        offer\n      });\n\n      // Handle when someone answers\n      let listener = answers.onSnapshot(snapshot => {\n        if (snapshot.exists) {\n          const {\n            answer\n          } = snapshot.data();\n          const answerDescription = new RTCSessionDescription(answer);\n          if (peer.pc.signalingState !== 'closed') {\n            try {\n              peer.pc.setRemoteDescription(answerDescription);\n            } catch (error) {\n              logger(error);\n            }\n          } else {\n            listener();\n            // delete session.current[sessionKey];\n            deleteSessionByKey(sessionKey);\n          }\n        }\n      });\n      peer.listeners.push(listener);\n\n      // Handle when answerers provide answer candidates\n      listener = answerCandidates.onSnapshot(snapshot => {\n        snapshot.docChanges().map(async change => {\n          if (change.type === 'added') {\n            const candidate = new RTCIceCandidate(change.doc.data());\n            if (peer.pc.signalingState !== 'closed') {\n              try {\n                await peer.pc.addIceCandidate(candidate);\n              } catch (error) {\n                logger(error);\n              }\n            } else {\n              if (peer.type === 'share') {\n                deleteSessionByKey('screen');\n                deleteSessionByKey('share_to_answer_screen');\n                deleteSessionByKey('share_to_offer_screen');\n              }\n              deleteSessionByKey(sessionKey);\n            }\n          }\n        });\n      });\n      peer.listeners.push(listener);\n\n      // Update session list\n      // session.current[sessionKey] = peer;\n      // setSessionState((currrentValue) => {\n      //   return {\n      //     ...currrentValue,\n      //     [sessionKey]: peer\n      //   }  \n      // })\n      addToSession(sessionKey, peer);\n      if (peerID !== userID && type !== ConnectType.share) {\n        createVideoComponent(peer, type);\n      }\n      return peer;\n    }\n    return session.current[peerID];\n  };\n  const createVideoComponent = (peer, type) => {\n    if (type === ConnectType.share) {\n      setIsSharing(true);\n      shareStream.current.getTracks().forEach(track => track.stop());\n      if (shareVideo.current !== null) {\n        shareVideo.current.muted = false;\n        shareVideo.current.volume = process.env.NODE_ENV === 'development' ? 0 : 0.2;\n        shareVideo.current.srcObject = peer.remoteStream;\n      } else {\n        let shareVideoEl = document.querySelector('#shareVideo');\n        shareVideoEl.muted = false;\n        shareVideoEl.volume = process.env.NODE_ENV === 'development' ? 0 : 0.2;\n        shareVideoEl.srcObject = peer.remoteStream;\n      }\n    }\n  };\n  const handleWebcam = async callType => {\n    try {\n      const constraints = {\n        video: false,\n        audio: true\n      };\n      const devices = await navigator.mediaDevices.enumerateDevices();\n      devices.forEach(device => {\n        if (device.kind === 'videoinput' && callType !== CALL_TYPE.audio) constraints.video = true;\n      });\n      if (constraints.video) setWebcam(true);\n      localStream.current = await navigator.mediaDevices.getUserMedia(constraints);\n    } catch (error) {\n      logger(error);\n      fireAlert('Failed to access Webcam and/or Mic', ALERT_TYPE.error);\n    }\n    localVideo.current.volume = 0;\n    localVideo.current.srcObject = localStream.current;\n  };\n  const handleCall = async () => {\n    // Create the room and add you as the first user with no peer connection at all\n    logger(`Call ID: ${callID.current}`);\n    const callDoc = db.collection('calls').doc(callID.current);\n    await callDoc.set({\n      time: new Date(),\n      callType: callType.current\n    });\n    const userDoc = callDoc.collection('users').doc(user.current);\n    const usersCollection = callDoc.collection('users');\n    await userDoc.set({\n      name: userName.current,\n      type: ConnectType.user,\n      time: new Date(),\n      status: 'active',\n      mute: mute\n    });\n    const screenDoc = callDoc.collection('users').doc('screen');\n\n    // Watch for new users to come in and create new peer connection\n    let listener = usersCollection.onSnapshot(async snapshot => {\n      const promises = snapshot.docChanges().filter(change => user.current !== change.doc.id).map(async change => {\n        if (change.type === 'added') {\n          const existingUserID = change.doc.id;\n          logger(existingUserID);\n          if (!session.current[existingUserID]) {\n            const u = change.doc.data();\n            if (u.type === ConnectType.user) {\n              logger(`User ${u.name} joined the call`);\n              fireAlert(`User ${u.name} joined the call`, ALERT_TYPE.success);\n              await createOfferPeer(callID.current, user.current, existingUserID, u.name, localStream.current);\n\n              // If sharing, then create offer for share stream too\n              const sharingCondition = Object.keys(session.current).reduce((accumulator, currrentValue) => {\n                if (currrentValue.indexOf('share_to_offer') !== -1) {\n                  return accumulator || true;\n                }\n                return accumulator;\n              }, false);\n              if (sharingCondition) {\n                await createOfferPeer(callID.current, 'screen', existingUserID, u.name, shareStream.current, ConnectType.share);\n              }\n            } else if (u.type === ConnectType.share) {\n              if (u.shareID !== user.current) {\n                logger(`User ${u.shareUserName} is sharing their screen`);\n                fireAlert(`User ${u.shareUserName} is sharing their screen`, ALERT_TYPE.success);\n\n                // Close your sharing if exist\n                shareStream.current.getTracks().forEach(track => track.stop());\n              } else {\n                logger(`You are sharing your screen`);\n                fireAlert(`You are sharing your screen`, ALERT_TYPE.success);\n              }\n            }\n          }\n        }\n      });\n      await Promise.all(promises);\n    });\n    globalListeners.current.push(listener);\n\n    // Socket to monitor who will share screen\n    listener = screenDoc.collection('offers').onSnapshot(async snapshot => {\n      const promises = snapshot.docChanges().filter(change => change.doc.id === user.current).map(async change => {\n        // const id = change.doc.id;\n        logger('Anticipating share screen');\n        // Clean up 'screen' session\n        Object.keys(session.current).forEach(key => {\n          if (session.current[key].type === ConnectType.share) {\n            // session.current[key].listeners.forEach((listener) => listener());\n            // session.current[key].pc.close();\n            // delete session.current[key];\n            deleteSessionByKey(key);\n          }\n        });\n        if (change.type === 'added') {\n          const {\n            offer\n          } = change.doc.data();\n          const answerPeer = await createAnswerPeer(callID.current, user.current, 'screen', 'Screen', offer, new MediaStream(), ConnectType.share);\n          // const listener = screenDoc.collection('offerCandidates').doc(user.current).collection('candidates').onSnapshot((ss) => {\n          //   ss.docChanges().forEach(async (cc) => {\n          //     if (cc.type === 'added') {\n          //       let data = cc.doc.data();\n          //       if (answerPeer.pc.signalingState !== 'closed') {\n          //         try {\n          //           await answerPeer.pc.addIceCandidate(new RTCIceCandidate(data));\n          //         }\n          //         catch (error) {\n          //           logger(error);\n          //         }\n          //       }\n          //       else {\n          //         listener();\n          //         deleteSessionByKey('screen');\n          //         deleteSessionByKey('share_to_answer_screen');\n          //         deleteSessionByKey('share_to_offer_screen');\n          //       }\n          //     }\n          //   });\n          // });\n          // answerPeer.listeners.push(listener);\n        }\n      });\n\n      await Promise.all(promises);\n    });\n    globalListeners.current.push(listener);\n  };\n  const deletePeerConnection = (key, peer) => {\n    logger(`Connection Disconnected - ${peer.name}`);\n    deleteSessionByKey(key);\n    if (peer.type === ConnectType.user) {\n      fireAlert(`${peer.name} disconnected.`, ALERT_TYPE.info);\n    }\n    [`share_to_offer_${peer.peerID}`,\n    // `share_to_offer_screen`,\n    `share_to_answer_${peer.peerID}`\n    // `share_to_answer_screen`,\n    ].forEach(key => {\n      deleteSessionByKey(key);\n    });\n  };\n  const createAnswerPeer = async (call, userID, offerID, name, offer, stream, type = ConnectType.user) => {\n    const callDoc = db.collection('calls').doc(call);\n    const userDoc = callDoc.collection('users').doc(offerID);\n    const answers = userDoc.collection('answers').doc(userID);\n    const offerCandidates = userDoc.collection('offerCandidates').doc(offerID).collection('candidates');\n    const answerCandidates = userDoc.collection('answerCandidates').doc(userID).collection('candidates');\n    const sessionKey = type === ConnectType.user ? offerID : `share_to_answer_${offerID}`;\n    const peer = {\n      name,\n      peerID: sessionKey,\n      pc: new RTCPeerConnection(config.servers),\n      remoteStream: new MediaStream(),\n      listeners: [],\n      type\n    };\n\n    // Handle Ice Candidate\n    peer.pc.onicecandidate = e => {\n      e.candidate && answerCandidates.add(e.candidate.toJSON());\n    };\n    // Push stream from local to remote\n    stream.getTracks().forEach(track => {\n      peer.pc.addTrack(track, stream);\n    });\n    // Handle Remote Stream\n    peer.pc.ontrack = e => {\n      e.streams.forEach(stream => {\n        stream.getTracks().forEach(track => {\n          peer.remoteStream.addTrack(track);\n        });\n      });\n    };\n    // Handle disconnect\n    peer.pc.onconnectionstatechange = e => {\n      switch (peer.pc.connectionState) {\n        case \"disconnected\":\n          {\n            deletePeerConnection(sessionKey, peer);\n            break;\n          }\n        case \"closed\":\n          {\n            deletePeerConnection(sessionKey, peer);\n            break;\n          }\n        case \"failed\":\n          {\n            deletePeerConnection(sessionKey, peer);\n            break;\n          }\n      }\n    };\n    await peer.pc.setRemoteDescription(new RTCSessionDescription(offer));\n    const answerDescription = await peer.pc.createAnswer();\n    if (peer.type === 'share') {\n      if (answerDescription.sdp) {\n        answerDescription.sdp.replace('useinbandfec=1', 'useinbandfec=1; stereo=1; maxaveragebitrate=510000');\n      }\n    }\n    await peer.pc.setLocalDescription(answerDescription);\n    const answer = {\n      sdp: answerDescription.sdp,\n      type: answerDescription.type\n    };\n    await answers.set({\n      answer\n    });\n\n    // Handle when offerers provide answer candidates\n    const listener = offerCandidates.onSnapshot(async snapshot => {\n      snapshot.docChanges().forEach(async change => {\n        if (change.type === 'added') {\n          let data = change.doc.data();\n          if (peer.pc.signalingState !== 'closed') {\n            try {\n              await peer.pc.addIceCandidate(new RTCIceCandidate(data));\n            } catch (error) {\n              logger(error);\n            }\n          } else {\n            const sessionKey = peer.type === ConnectType.user ? offerID : `share_to_answer_${offerID}`;\n            deleteSessionByKey(sessionKey);\n            // delete session.current[sessionKey];\n          }\n        }\n      });\n    });\n\n    peer.listeners.push(listener);\n    addToSession(sessionKey, peer);\n    if (offerID !== userID) {\n      createVideoComponent(peer, type);\n    }\n    return peer;\n  };\n  const handleAnswer = async () => {\n    logger(`Call ID: ${callID.current}`);\n    // Add yourself to the list of uers\n    const callDoc = db.collection('calls').doc(callID.current);\n    const testCall = await callDoc.get();\n    if (!testCall.exists) {\n      fireAlert('Invalid Call ID. Please try again with a valid one.', ALERT_TYPE.error);\n      return;\n    }\n    const userDoc = callDoc.collection('users').doc(user.current);\n    await userDoc.set({\n      name: userName.current,\n      type: ConnectType.user,\n      time: new Date(),\n      status: 'active',\n      mute: mute\n    });\n    const usersCollection = callDoc.collection('users');\n    const screenDoc = callDoc.collection('users').doc('screen');\n\n    // Go through all existing users and connect to them using their offer for your user ID\n    const promises = (await usersCollection.get()).docs.filter(u => u.id !== user.current).map(async doc => {\n      const id = doc.id;\n      const u = doc.data();\n      doc.ref.collection('offers').doc(user.current).onSnapshot(async snapshot => {\n        if (snapshot.exists) {\n          if (u.type !== ConnectType.share) {\n            logger(`Retrieving offers from ${id} -- ${u.name}`);\n            const {\n              offer\n            } = snapshot.data();\n            const answerPeer = await createAnswerPeer(callID.current, user.current, id, u.name, offer, localStream.current);\n\n            // const listener = doc.ref.collection('offerCandidates').doc(user.current).collection('candidates').onSnapshot((snapshot) => {\n            //   snapshot.docChanges().forEach(async (change) => {\n            //     if (change.type === 'added') {\n            //       let data = change.doc.data();\n            //       if (answerPeer.pc.signalingState !== 'closed') {\n            //         try {\n            //           await answerPeer.pc.addIceCandidate(new RTCIceCandidate(data));\n            //         }\n            //         catch (error) {\n            //           logger(error);\n            //         }\n            //       }\n            //       else {\n            //         listener();\n            //         const sessionKey = answerPeer.type === ConnectType.user ? id : `share_to_answer_${id}`;\n            //         deleteSessionByKey(sessionKey);\n            //         // delete session.current[sessionKey];\n            //       }\n            //     }\n            //   });\n            // });\n            // answerPeer.listeners.push(listener);\n          }\n        }\n      });\n    });\n\n    await Promise.all(promises);\n\n    // Watch for new users to come in and create new peer connection\n    let listener = usersCollection.onSnapshot(async snapshot => {\n      if (Object.keys(session.current).length > 0) {\n        const promises = snapshot.docChanges().filter(change => user.current !== change.doc.id).map(async change => {\n          if (change.type === 'added') {\n            const existingUserID = change.doc.id;\n            if (!session.current[existingUserID]) {\n              const u = change.doc.data();\n              if (u.type === ConnectType.user) {\n                logger(`User ${u.name} joined the call`);\n                fireAlert(`User ${u.name} joined the call`, ALERT_TYPE.success);\n                await createOfferPeer(callID.current, user.current, existingUserID, u.name, localStream.current);\n\n                // If sharing, then create offer for share stream too\n                const sharingCondition = Object.keys(session.current).reduce((accumulator, currrentValue) => {\n                  if (currrentValue.indexOf('share_to_offer') !== -1) {\n                    return accumulator || true;\n                  }\n                  return accumulator;\n                }, false);\n                if (sharingCondition) {\n                  await createOfferPeer(callID.current, 'screen', existingUserID, u.name, shareStream.current, ConnectType.share);\n                }\n              } else if (u.type === ConnectType.share) {\n                if (u.shareID !== user.current) {\n                  logger(`User ${u.shareUserName} is sharing their screen`);\n                  fireAlert(`User ${u.shareUserName} is sharing their screen`, ALERT_TYPE.success);\n                  // Close your sharing if exist\n                  shareStream.current.getTracks().forEach(track => track.stop());\n                } else {\n                  logger(`You are sharing your screen`);\n                  fireAlert(`You are sharing your screen`, ALERT_TYPE.success);\n                }\n              }\n            }\n          }\n        });\n        await Promise.all(promises);\n      }\n    });\n    globalListeners.current.push(listener);\n\n    // Socket to monitor who will share screen\n    listener = screenDoc.collection('offers').onSnapshot(async snapshot => {\n      const promises = snapshot.docChanges().filter(change => change.doc.id === user.current).map(async change => {\n        // const id = change.doc.id;\n        logger('Anticipating share screen');\n        // Clean up 'screen' session\n        Object.keys(session.current).forEach(key => {\n          if (session.current[key].type === ConnectType.share) {\n            // session.current[key].listeners.forEach((listener) => listener());\n            // session.current[key].pc.close();\n            // delete session.current[key];\n            deleteSessionByKey(key);\n          }\n        });\n        if (change.type === 'added') {\n          const {\n            offer\n          } = change.doc.data();\n          const answerPeer = await createAnswerPeer(callID.current, user.current, 'screen', 'Screen', offer, new MediaStream(), ConnectType.share);\n          const listener = screenDoc.collection('offerCandidates').doc(user.current).collection('candidates').onSnapshot(ss => {\n            ss.docChanges().forEach(async cc => {\n              if (cc.type === 'added') {\n                let data = cc.doc.data();\n                if (answerPeer.pc.signalingState !== 'closed') {\n                  try {\n                    await answerPeer.pc.addIceCandidate(new RTCIceCandidate(data));\n                  } catch (error) {\n                    logger(error);\n                  }\n                } else {\n                  listener();\n                  deleteSessionByKey('screen');\n                  deleteSessionByKey('share_to_answer_screen');\n                  deleteSessionByKey('share_to_offer_screen');\n                }\n              }\n            });\n          });\n          answerPeer.listeners.push(listener);\n        }\n      });\n      await Promise.all(promises);\n    });\n    globalListeners.current.push(listener);\n  };\n  const handleShareScreen = async () => {\n    if (Object.keys(session.current).length === 0) {\n      fireAlert('Cannot share screen in empty room. Please wait for more folks to join.', ALERT_TYPE.info);\n      return;\n    }\n\n    // Turn on sharing screen view\n    setIsSharing(true);\n    try {\n      shareStream.current.getTracks().forEach(track => track.stop());\n      const castDevices = navigator.mediaDevices;\n      shareStream.current = await castDevices.getDisplayMedia({\n        audio: {\n          echoCancellation: false,\n          autoGainControl: false,\n          noiseSuppression: false,\n          latency: 0,\n          channelCount: 2,\n          sampleRate: 48000,\n          sampleSize: 16\n        },\n        video: {\n          frameRate: 60\n        }\n      });\n      shareVideo.current.muted = false;\n      shareVideo.current.volume = 0;\n      shareVideo.current.srcObject = shareStream.current;\n      const callDoc = db.collection('calls').doc(callID.current);\n      const userDoc = callDoc.collection('users').doc(`screen`);\n\n      // Clean up 'screen' session\n      Object.keys(session.current).forEach(key => {\n        if (session.current[key].type === ConnectType.share) {\n          deleteSessionByKey(key);\n          // session.current[key].listeners.forEach((listener) => listener());\n          // session.current[key].pc.close();\n          // delete session.current[key];\n        }\n      });\n\n      // Delete Screen record. Will need to move to cloud function later\n      const _offers = await userDoc.collection('offers').get();\n      _offers.docs.forEach(_offer => _offer.ref.delete());\n      const _offerCandidates = await userDoc.collection('offerCandidates').get();\n      let _ps = _offerCandidates.docs.map(async _offerCandidate => {\n        const candidates = await _offerCandidate.ref.collection('candidates').get();\n        candidates.forEach(candidate => candidate.ref.delete());\n      });\n      await Promise.all(_ps);\n      const _answers = await userDoc.collection('answers').get();\n      _answers.docs.forEach(_answer => _answer.ref.delete());\n      const _answerCandidates = await userDoc.collection('answerCandidates').get();\n      _ps = _answerCandidates.docs.map(async _answerCandidate => {\n        const candidates = await _answerCandidate.ref.collection('candidates').get();\n        candidates.forEach(candidate => candidate.ref.delete());\n      });\n      await Promise.all(_ps);\n      await userDoc.delete();\n\n      // Update screen user\n      await userDoc.set({\n        name: 'Screen Share',\n        type: ConnectType.share,\n        shareID: user.current,\n        shareUserName: userName.current,\n        time: new Date(),\n        status: 'active',\n        mute: false\n      });\n\n      // Create offers and candidates for each user\n      // const promises = (await callDoc.collection('users').get()).docs\n      //   .filter((doc) => user.current !== doc.id && doc.data().type !== ConnectType.share)\n      //   .map(async (doc) => {\n      //   const existingUserID = doc.id;\n      //   const data = doc.data() as User;\n      //   await createOfferPeer(callID.current, 'screen', existingUserID, data.name, shareStream.current, ConnectType.share);\n      // });\n      // await Promise.all(promises);\n      Object.values(session.current).filter(peer => peer.type !== ConnectType.share && user.current !== peer.peerID).forEach(peer => {\n        createOfferPeer(callID.current, 'screen', peer.peerID, peer.name, shareStream.current, ConnectType.share);\n      });\n\n      // Analytics\n      analytics.logEvent('share_screen', {\n        name: userName.current,\n        callID: callID.current,\n        userID: user.current\n      });\n      // Socket to create new peers for sharing when new user join in as well\n      // Clear current listener so we don't pile on them\n      // shareUserListener.current();\n      // const usersCollection = callDoc.collection('users');\n      // shareUserListener.current = usersCollection.onSnapshot(async (snapshot) => {\n      //   const ps = snapshot.docChanges()\n      //     .filter((change) => !session.current[change.doc.id] && change.doc.id !== user.current && change.doc.data().type !== ConnectType.share)\n      //     .map(async (change) => {\n      //       if (change.type === 'added') {\n      //           const newUserID = change.doc.id;\n      //           const data = change.doc.data() as User;\n      //           await createOfferPeer(callID.current, 'screen', newUserID, data.name, shareStream.current, ConnectType.share);\n      //       }\n      //     });\n\n      //   await Promise.all(ps);\n      // });\n    } catch (error) {\n      logger(error);\n      fireAlert('Failed to share screen. Please rejoin and try again.', ALERT_TYPE.error);\n      setIsSharing(false);\n    }\n  };\n  const handleRoomID = () => {\n    if (clipboardRef.current) {\n      if (clipboardRef.current.value.length > 0) {\n        clipboardRef.current.select();\n        document.execCommand('copy');\n        fireAlert(`Call ID copied into clipboard.`, ALERT_TYPE.info);\n      }\n    }\n  };\n  const handleMute = async () => {\n    localStream.current.getAudioTracks().forEach(track => track.enabled = mute);\n    await db.collection('calls').doc(callID.current).collection('users').doc(user.current).update({\n      mute: !mute\n    });\n    setMute(!mute);\n  };\n  const handleEndCall = () => {\n    shareStream.current.getTracks().forEach(track => track.stop());\n    localStream.current.getTracks().forEach(track => track.stop());\n    Object.keys(session.current).forEach(key => {\n      deleteSessionByKey(key);\n    });\n    globalListeners.current.forEach(listener => listener());\n\n    // Analytics\n    analytics.logEvent('end_call', {\n      name: userName.current,\n      callID: callID.current,\n      userID: user.current\n    });\n    fireAlert('Ending call...', ALERT_TYPE.info);\n    setTimeout(() => {\n      history.push(ROUTES.JOIN);\n    }, 2000);\n  };\n  const toggleWebcam = async () => {\n    if (!webcam) {\n      localStream.current.getVideoTracks().forEach(videoTrack => videoTrack.enabled = true);\n      localVideo.current.srcObject = localStream.current;\n    } else {\n      localStream.current.getVideoTracks().forEach(videoTrack => videoTrack.enabled = false);\n      localVideo.current.srcObject = null;\n    }\n    setWebcam(!webcam);\n  };\n  return /*#__PURE__*/_jsxDEV(_Fragment, {\n    children: [/*#__PURE__*/_jsxDEV(\"div\", {\n      id: \"roomContainer\",\n      className: isSharing ? 'sharing' : 'standalone',\n      children: [isSharing ? /*#__PURE__*/_jsxDEV(\"div\", {\n        id: \"shareContainer\",\n        ref: shareContainer,\n        children: [/*#__PURE__*/_jsxDEV(\"div\", {\n          className: \"videos\",\n          children: /*#__PURE__*/_jsxDEV(\"span\", {\n            children: /*#__PURE__*/_jsxDEV(\"video\", {\n              id: \"shareVideo\",\n              ref: shareVideo,\n              autoPlay: true,\n              playsInline: true,\n              muted: true\n            }, void 0, false, {\n              fileName: _jsxFileName,\n              lineNumber: 870,\n              columnNumber: 19\n            }, this)\n          }, void 0, false, {\n            fileName: _jsxFileName,\n            lineNumber: 869,\n            columnNumber: 17\n          }, this)\n        }, void 0, false, {\n          fileName: _jsxFileName,\n          lineNumber: 868,\n          columnNumber: 15\n        }, this), /*#__PURE__*/_jsxDEV(ActionButtons, {\n          shareVideoRef: shareVideo,\n          handleRoomID: handleRoomID,\n          handleShareScreen: handleShareScreen,\n          handleEndCall: handleEndCall\n        }, void 0, false, {\n          fileName: _jsxFileName,\n          lineNumber: 873,\n          columnNumber: 15\n        }, this)]\n      }, void 0, true, {\n        fileName: _jsxFileName,\n        lineNumber: 867,\n        columnNumber: 13\n      }, this) : '', /*#__PURE__*/_jsxDEV(\"div\", {\n        ref: videoContainer,\n        id: \"videoContainer\",\n        children: [Object.values(sessionState).filter(peer => peer.peerID !== user.current && peer.type !== ConnectType.share).map(peer => /*#__PURE__*/_jsxDEV(Video, {\n          peer: peer,\n          callID: callID.current\n        }, peer.peerID, false, {\n          fileName: _jsxFileName,\n          lineNumber: 889,\n          columnNumber: 30\n        }, this)), /*#__PURE__*/_jsxDEV(\"div\", {\n          className: \"videos\",\n          id: \"localVideoContainer\",\n          children: [/*#__PURE__*/_jsxDEV(\"span\", {\n            children: /*#__PURE__*/_jsxDEV(\"video\", {\n              id: \"localVideo\",\n              ref: localVideo,\n              autoPlay: true,\n              playsInline: true,\n              poster: `${process.env.PUBLIC_URL}/user_placeholer.`\n            }, void 0, false, {\n              fileName: _jsxFileName,\n              lineNumber: 921,\n              columnNumber: 15\n            }, this)\n          }, void 0, false, {\n            fileName: _jsxFileName,\n            lineNumber: 920,\n            columnNumber: 13\n          }, this), /*#__PURE__*/_jsxDEV(\"div\", {\n            className: \"name\",\n            children: [/*#__PURE__*/_jsxDEV(\"div\", {\n              children: userName.current\n            }, void 0, false, {\n              fileName: _jsxFileName,\n              lineNumber: 924,\n              columnNumber: 15\n            }, this), /*#__PURE__*/_jsxDEV(\"div\", {\n              children: /*#__PURE__*/_jsxDEV(Tooltip, {\n                title: mute ? 'Unmute' : 'Mute',\n                placement: \"top\",\n                onClick: handleMute,\n                children: mute ? /*#__PURE__*/_jsxDEV(VolumeOffSharpIcon, {\n                  fontSize: \"small\"\n                }, void 0, false, {\n                  fileName: _jsxFileName,\n                  lineNumber: 930,\n                  columnNumber: 28\n                }, this) : /*#__PURE__*/_jsxDEV(VolumeUpSharpIcon, {\n                  fontSize: \"small\"\n                }, void 0, false, {\n                  fileName: _jsxFileName,\n                  lineNumber: 930,\n                  columnNumber: 69\n                }, this)\n              }, void 0, false, {\n                fileName: _jsxFileName,\n                lineNumber: 928,\n                columnNumber: 17\n              }, this)\n            }, void 0, false, {\n              fileName: _jsxFileName,\n              lineNumber: 927,\n              columnNumber: 15\n            }, this)]\n          }, void 0, true, {\n            fileName: _jsxFileName,\n            lineNumber: 923,\n            columnNumber: 13\n          }, this), /*#__PURE__*/_jsxDEV(\"div\", {\n            className: \"action\",\n            children: [/*#__PURE__*/_jsxDEV(Tooltip, {\n              title: mute ? 'Unmute' : 'Mute',\n              placement: \"bottom\",\n              children: /*#__PURE__*/_jsxDEV(Fab, {\n                \"aria-label\": \"mute_toggle\",\n                size: \"small\",\n                onClick: handleMute,\n                children: mute ? /*#__PURE__*/_jsxDEV(VolumeOffSharpIcon, {\n                  fontSize: \"small\"\n                }, void 0, false, {\n                  fileName: _jsxFileName,\n                  lineNumber: 939,\n                  columnNumber: 28\n                }, this) : /*#__PURE__*/_jsxDEV(VolumeUpSharpIcon, {\n                  fontSize: \"small\"\n                }, void 0, false, {\n                  fileName: _jsxFileName,\n                  lineNumber: 939,\n                  columnNumber: 69\n                }, this)\n              }, void 0, false, {\n                fileName: _jsxFileName,\n                lineNumber: 937,\n                columnNumber: 17\n              }, this)\n            }, void 0, false, {\n              fileName: _jsxFileName,\n              lineNumber: 936,\n              columnNumber: 15\n            }, this), \"\\xA0\", /*#__PURE__*/_jsxDEV(Tooltip, {\n              title: webcam ? 'Camera Off' : 'Camera On',\n              placement: \"bottom\",\n              children: /*#__PURE__*/_jsxDEV(Fab, {\n                \"aria-label\": \"webcam_toggle\",\n                size: \"small\",\n                onClick: toggleWebcam,\n                children: webcam ? /*#__PURE__*/_jsxDEV(VideocamOffSharpIcon, {\n                  fontSize: \"small\"\n                }, void 0, false, {\n                  fileName: _jsxFileName,\n                  lineNumber: 947,\n                  columnNumber: 30\n                }, this) : /*#__PURE__*/_jsxDEV(VideocamSharpIcon, {\n                  fontSize: \"small\"\n                }, void 0, false, {\n                  fileName: _jsxFileName,\n                  lineNumber: 947,\n                  columnNumber: 73\n                }, this)\n              }, void 0, false, {\n                fileName: _jsxFileName,\n                lineNumber: 945,\n                columnNumber: 17\n              }, this)\n            }, void 0, false, {\n              fileName: _jsxFileName,\n              lineNumber: 944,\n              columnNumber: 15\n            }, this)]\n          }, void 0, true, {\n            fileName: _jsxFileName,\n            lineNumber: 935,\n            columnNumber: 13\n          }, this)]\n        }, void 0, true, {\n          fileName: _jsxFileName,\n          lineNumber: 919,\n          columnNumber: 11\n        }, this)]\n      }, void 0, true, {\n        fileName: _jsxFileName,\n        lineNumber: 883,\n        columnNumber: 9\n      }, this), !isSharing ? /*#__PURE__*/_jsxDEV(\"div\", {\n        id: \"standalone_share\",\n        children: /*#__PURE__*/_jsxDEV(ActionButtons, {\n          shareVideoRef: shareVideo,\n          handleRoomID: handleRoomID,\n          handleShareScreen: handleShareScreen,\n          handleEndCall: handleEndCall\n        }, void 0, false, {\n          fileName: _jsxFileName,\n          lineNumber: 959,\n          columnNumber: 15\n        }, this)\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 958,\n        columnNumber: 13\n      }, this) : '']\n    }, void 0, true, {\n      fileName: _jsxFileName,\n      lineNumber: 863,\n      columnNumber: 7\n    }, this), /*#__PURE__*/_jsxDEV(\"input\", {\n      id: \"clipboard\",\n      ref: clipboardRef,\n      value: callID.current,\n      onChange: () => {}\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 971,\n      columnNumber: 7\n    }, this), /*#__PURE__*/_jsxDEV(CustomizedAlert, {\n      duration: 5000,\n      openAlert: openAlert,\n      setOpenAlert: setOpenAlert,\n      alertMessage: alertMessage,\n      alertType: alertType\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 972,\n      columnNumber: 7\n    }, this)]\n  }, void 0, true);\n};\n_s(Room, \"Zq/a3lVYm9CyIdeZGZ1y1W+/csw=\", false, function () {\n  return [useLocation, useHistory, useAlert];\n});\n_c = Room;\nvar _c;\n$RefreshReg$(_c, \"Room\");","map":{"version":3,"names":["React","db","analytics","config","CustomizedAlert","ActionButtons","Video","useHistory","useLocation","VolumeOffSharpIcon","VolumeUpSharpIcon","VideocamSharpIcon","VideocamOffSharpIcon","Tooltip","Fab","ConnectType","ALERT_TYPE","CALL_TYPE","useAlert","ROUTES","logger","jsxDEV","_jsxDEV","Fragment","_Fragment","useRef","useEffect","useState","Room","_s","clipboardRef","localVideo","shareVideo","shareContainer","videoContainer","session","globalListeners","localStream","MediaStream","shareStream","callID","callType","video","user","userName","location","history","openAlert","setAlertMessage","setOpenAlert","alertMessage","alertType","fireAlert","sessionState","setSessionState","mute","setMute","webcam","setWebcam","isSharing","setIsSharing","addToSession","key","peer","current","deleteSessionByKey","currentSession","pc","close","listeners","forEach","listener","main","state","error","setTimeout","handleEndCall","userID","name","action","handleWebcam","handleCall","handleAnswer","replace","pathname","ROOM","undefined","Object","keys","createOfferPeer","call","peerID","stream","type","sessionKey","callDoc","collection","doc","userDoc","offers","answers","offerCandidates","answerCandidates","RTCPeerConnection","servers","remoteStream","getTracks","track","addTrack","ontrack","e","streams","onconnectionstatechange","connectionState","deletePeerConnection","onicecandidate","candidate","add","toJSON","offerDescription","createOffer","setLocalDescription","offer","sdp","set","onSnapshot","snapshot","exists","answer","data","answerDescription","RTCSessionDescription","signalingState","setRemoteDescription","push","docChanges","map","change","RTCIceCandidate","addIceCandidate","share","createVideoComponent","stop","muted","volume","process","env","NODE_ENV","srcObject","shareVideoEl","document","querySelector","constraints","audio","devices","navigator","mediaDevices","enumerateDevices","device","kind","getUserMedia","time","Date","usersCollection","status","screenDoc","promises","filter","id","existingUserID","u","success","sharingCondition","reduce","accumulator","currrentValue","indexOf","shareID","shareUserName","Promise","all","answerPeer","createAnswerPeer","info","offerID","createAnswer","testCall","get","docs","ref","length","ss","cc","handleShareScreen","castDevices","getDisplayMedia","echoCancellation","autoGainControl","noiseSuppression","latency","channelCount","sampleRate","sampleSize","frameRate","_offers","_offer","delete","_offerCandidates","_ps","_offerCandidate","candidates","_answers","_answer","_answerCandidates","_answerCandidate","values","logEvent","handleRoomID","value","select","execCommand","handleMute","getAudioTracks","enabled","update","JOIN","toggleWebcam","getVideoTracks","videoTrack","children","className","autoPlay","playsInline","fileName","_jsxFileName","lineNumber","columnNumber","shareVideoRef","poster","PUBLIC_URL","title","placement","onClick","fontSize","size","onChange","duration","_c","$RefreshReg$"],"sources":["E:/projects/longmeet-lets-thango-main/src/components/Room/Room.tsx"],"sourcesContent":["import * as React from 'react';\nimport { db, analytics } from '../../libs';\nimport { config } from '../../shared';\nimport './Room.css';\nimport { CustomizedAlert } from '../';\nimport { ActionButtons } from './ActionButtons';\nimport { Video } from './Video';\nimport { useHistory, useLocation } from 'react-router';\nimport VolumeOffSharpIcon from '@material-ui/icons/VolumeOffSharp';\nimport VolumeUpSharpIcon from '@material-ui/icons/VolumeUpSharp';\nimport VideocamSharpIcon from '@material-ui/icons/VideocamSharp';\nimport VideocamOffSharpIcon from '@material-ui/icons/VideocamOffSharp';\nimport Tooltip from '@material-ui/core/Tooltip';\nimport Fab from '@material-ui/core/Fab';\n\nimport {\n  Session,\n  ConnectType,\n  Peer,\n  Offer,\n  CastDevices,\n  User,\n  ALERT_TYPE,\n  CALL_TYPE\n} from '../../interfaces';\nimport { useAlert } from '../../hooks';\nimport * as ROUTES from '../../routes';\nimport { logger } from '../../utils';\n\nconst { useRef, useEffect, useState } = React;\n\nexport const Room = () => {\n  const clipboardRef = useRef<HTMLInputElement>(null);\n  const localVideo = useRef<HTMLVideoElement>(null);\n  const shareVideo = useRef<HTMLVideoElement>(null);\n  const shareContainer = useRef<HTMLDivElement>(null);\n  const videoContainer = useRef<HTMLDivElement>(null);\n  const session = useRef<Session>({});\n  const globalListeners = useRef<Function[]>([]);\n  const localStream = useRef<MediaStream>(new MediaStream());\n  const shareStream = useRef<MediaStream>(new MediaStream());\n  const callID = useRef<string>('');\n  const callType = useRef<keyof typeof CALL_TYPE>(CALL_TYPE.video);\n  const user = useRef<string>('');\n  const userName = useRef<string>('');\n  const location = useLocation();\n  const history = useHistory();\n  const { openAlert, setAlertMessage, setOpenAlert, alertMessage, alertType, fireAlert} = useAlert();\n  const [sessionState, setSessionState] = useState<Session>({});\n  const [mute, setMute] = useState<boolean>(false);\n  const [webcam, setWebcam] = useState<boolean>(false);\n  const [isSharing, setIsSharing] = useState<boolean>(false);\n\n  const addToSession = (key: string, peer: Peer) => {\n    if (session.current[key]) {\n      logger(`Duplicate key ${key}`);\n      deleteSessionByKey(key);\n      addToSession(key, peer);\n    }\n    else {\n      session.current[key] = peer;\n      setSessionState((currentSession) => {\n        return ({\n          ...currentSession,\n          [key]: peer\n        })\n      });\n    }\n    logger(session.current);\n  }\n  const deleteSessionByKey = (key: string) => {\n    if (session.current[key]) {\n      logger(`Deleting ${key}`);\n      session.current[key].pc.close();\n      session.current[key].listeners.forEach((listener) => listener());\n      delete session.current[key];\n      setSessionState(session.current);\n    }\n    else {\n      logger(`${key} does not exist.`);\n    }\n  }\n\n  useEffect(() => {\n\n    // Interval to update videos\n    // const interval = setInterval(sessionCallback, 1000);\n\n    const main = async () => {\n      try {\n        if (!location.state) {\n          fireAlert('Invalid State. Please join or create call via the appropriate screen.', ALERT_TYPE.error);\n\n          setTimeout(() => {\n            handleEndCall();\n          }, 1500)\n        }\n        else {\n          const state = location.state as { action: 'call' | 'answer', name: string, callID: string, callType: keyof typeof CALL_TYPE, userID: string };\n          callID.current = state.callID;\n          user.current = state.userID;\n          userName.current = state.name;\n          callType.current = state.callType;\n          switch (state.action) {\n            case 'call': {\n              await handleWebcam(callType.current);\n              await handleCall();\n              break;\n            }\n            case 'answer': {\n              await handleWebcam(callType.current);\n              await handleAnswer();\n            }\n          }\n\n          // If it's a reload, nuke state\n          history.replace({ pathname: ROUTES.ROOM, state: undefined });\n        }\n      }\n      catch (error) {\n        logger(error);\n        setAlertMessage('Call Failed. Please exit and create a new call.')\n        setOpenAlert(true);\n      }\n    }\n    main();\n\n    return () => {\n      // clearInterval(interval);\n      // Undo as many listeners as possibe\n      // eslint-disable-next-line\n      Object.keys(session.current).forEach((key) => {\n        // peer.listeners.forEach((listener) => listener());\n        deleteSessionByKey(key);\n      });\n      // eslint-disable-next-line\n      globalListeners.current.forEach((listener) => listener());\n    }\n  // eslint-disable-next-line\n  }, []);\n\n  const createOfferPeer = async (call: string, userID: string, peerID: string, name: string, stream: MediaStream, type = ConnectType.user) => {\n    const sessionKey = type === ConnectType.user ? peerID : `share_to_offer_${peerID}`;\n\n    if (!session.current[sessionKey]) {\n      // Socket Connections\n      const callDoc = db.collection('calls').doc(call);\n      const userDoc = callDoc.collection('users').doc(userID);\n      const offers = userDoc.collection('offers').doc(peerID);\n      const answers = userDoc.collection('answers').doc(peerID);\n      const offerCandidates = userDoc.collection('offerCandidates').doc(peerID).collection('candidates');\n      const answerCandidates = userDoc.collection('answerCandidates').doc(peerID).collection('candidates');\n\n      const peer: Peer = {\n        name,\n        peerID: sessionKey,\n        pc: new RTCPeerConnection(config.servers),\n        remoteStream: new MediaStream(),\n        listeners: [],\n        type\n      };\n\n      // Push tracks from local stream to peer connection\n      stream.getTracks().forEach((track) => {\n        peer.pc.addTrack(track, stream);\n      });\n      peer.pc.ontrack = (e) => {\n        e.streams.forEach((stream) => {\n          stream.getTracks().forEach((track) => {\n            peer.remoteStream.addTrack(track);\n          })\n        });\n      }\n\n      // Handle disconnect\n      peer.pc.onconnectionstatechange = (e) => {\n        switch (peer.pc.connectionState) {\n        case \"disconnected\":\n          {\n            deletePeerConnection(sessionKey, peer);\n            break;\n          }\n        case \"closed\":\n          { \n            deletePeerConnection(sessionKey, peer);\n            break;\n          }\n        case \"failed\":\n          { \n            deletePeerConnection(sessionKey, peer);\n            break;\n          }\n        }\n      }\n\n      // Handle Ice Candidate\n      peer.pc.onicecandidate = (e) => {\n        e.candidate && offerCandidates.add(e.candidate.toJSON());\n      }\n\n      const offerDescription = await peer.pc.createOffer();\n      await peer.pc.setLocalDescription(offerDescription);\n\n      const offer: RTCSessionDescriptionInit = {\n        sdp: offerDescription.sdp,\n        type: offerDescription.type\n      }\n      // Push offer to user's specific record\n      await offers.set({ offer });\n\n      // Handle when someone answers\n      let listener = answers.onSnapshot((snapshot) => {\n        if (snapshot.exists) {\n          const { answer } = snapshot.data() as { answer: RTCSessionDescription };\n          const answerDescription = new RTCSessionDescription(answer);\n          if (peer.pc.signalingState !== 'closed') {\n            try {\n              peer.pc.setRemoteDescription(answerDescription);\n            }\n            catch (error) {\n              logger(error);\n            }\n          }\n          else {\n            listener();\n            // delete session.current[sessionKey];\n            deleteSessionByKey(sessionKey);\n          }\n        }\n      });\n      peer.listeners.push(listener);\n\n      // Handle when answerers provide answer candidates\n      listener = answerCandidates.onSnapshot((snapshot) => {\n        snapshot.docChanges().map(async (change) => {\n          if (change.type === 'added') {\n            const candidate = new RTCIceCandidate(change.doc.data());\n            if (peer.pc.signalingState !== 'closed') {\n              try {\n                await peer.pc.addIceCandidate(candidate);\n              }\n              catch (error) {\n                logger(error);\n              }\n            }\n            else {\n              if (peer.type === 'share') {\n                  deleteSessionByKey('screen');\n                  deleteSessionByKey('share_to_answer_screen');\n                  deleteSessionByKey('share_to_offer_screen');\n              }\n              deleteSessionByKey(sessionKey);\n            }\n          }\n        })\n      });\n      peer.listeners.push(listener);\n\n      // Update session list\n      // session.current[sessionKey] = peer;\n      // setSessionState((currrentValue) => {\n      //   return {\n      //     ...currrentValue,\n      //     [sessionKey]: peer\n      //   }  \n      // })\n      addToSession(sessionKey, peer);\n\n      if (peerID !== userID && type !== ConnectType.share) {\n        createVideoComponent(peer, type);\n      }\n\n      return peer;\n    }\n    return session.current[peerID];\n  }\n\n  const createVideoComponent = (peer: Peer, type: ConnectType) => {\n    if (type === ConnectType.share) {\n      setIsSharing(true);\n      shareStream.current.getTracks().forEach((track) => track.stop());\n      if (shareVideo.current !== null) {\n        shareVideo.current.muted = false;\n        shareVideo.current.volume = process.env.NODE_ENV === 'development' ? 0 : 0.2;\n        shareVideo.current.srcObject = peer.remoteStream;\n      }\n      else {\n        let shareVideoEl = document.querySelector('#shareVideo') as HTMLVideoElement;\n        shareVideoEl.muted = false;\n        shareVideoEl.volume = process.env.NODE_ENV === 'development' ? 0 : 0.2;\n        shareVideoEl.srcObject = peer.remoteStream;\n      }\n    }\n  };\n\n  const handleWebcam = async (callType: keyof typeof CALL_TYPE) => {\n    try {\n      const constraints: { video?: boolean, audio?: boolean } = {\n        video: false,\n        audio: true\n      };\n      const devices = await navigator.mediaDevices.enumerateDevices();\n\n      devices.forEach((device) => {\n        if (device.kind === 'videoinput' && callType !== CALL_TYPE.audio) constraints.video = true;\n      });\n      if (constraints.video) setWebcam(true);\n\n      localStream.current = await navigator.mediaDevices.getUserMedia(constraints);\n    }\n    catch (error) {\n      logger(error);\n      fireAlert('Failed to access Webcam and/or Mic', ALERT_TYPE.error);\n    }\n\n    localVideo.current!.volume = 0;\n    localVideo.current!.srcObject = localStream.current;\n  }\n\n  const handleCall = async () => {\n    // Create the room and add you as the first user with no peer connection at all\n    logger(`Call ID: ${callID.current}`);\n    const callDoc = db.collection('calls').doc(callID.current);\n    await callDoc.set({ time: new Date(), callType: callType.current });\n    const userDoc = callDoc.collection('users').doc(user.current);\n    const usersCollection = callDoc.collection('users');\n    await userDoc.set({ name: userName.current, type: ConnectType.user, time: new Date(), status: 'active', mute: mute });\n    const screenDoc = callDoc.collection('users').doc('screen');\n\n    // Watch for new users to come in and create new peer connection\n    let listener = usersCollection.onSnapshot(async (snapshot) => {\n      const promises = snapshot.docChanges()\n        .filter((change) => user.current !== change.doc.id)\n        .map(async (change) => {\n          if (change.type === 'added') {\n            const existingUserID = change.doc.id;\n            logger(existingUserID);\n            if (!session.current[existingUserID]) {\n              const u = change.doc.data();\n              \n              if (u.type === ConnectType.user) {\n                logger(`User ${u.name} joined the call`);\n                fireAlert(`User ${u.name} joined the call`, ALERT_TYPE.success);\n                await createOfferPeer(callID.current, user.current, existingUserID, u.name, localStream.current);\n\n                // If sharing, then create offer for share stream too\n                const sharingCondition = Object.keys(session.current).reduce((accumulator: boolean, currrentValue: string) => {\n                  if (currrentValue.indexOf('share_to_offer') !== -1) {\n                    return accumulator || true;\n                  }\n                  return accumulator;\n                }, false);\n                if (sharingCondition) {\n                  await createOfferPeer(callID.current, 'screen', existingUserID, u.name, shareStream.current, ConnectType.share);\n                }\n              }\n              else if (u.type === ConnectType.share) {\n                if (u.shareID !== user.current) {\n                  logger(`User ${u.shareUserName} is sharing their screen`);\n                  fireAlert(`User ${u.shareUserName} is sharing their screen`, ALERT_TYPE.success);\n\n                  // Close your sharing if exist\n                  shareStream.current.getTracks().forEach((track) => track.stop());\n                }\n                else {\n                  logger(`You are sharing your screen`);\n                  fireAlert(`You are sharing your screen`, ALERT_TYPE.success);\n                }\n              }\n            }\n          }\n        });\n      \n      await Promise.all(promises);\n    });\n    globalListeners.current.push(listener);\n\n    // Socket to monitor who will share screen\n    listener = screenDoc.collection('offers').onSnapshot(async (snapshot) => {\n      const promises = snapshot.docChanges()\n        .filter((change) => change.doc.id === user.current)\n        .map(async (change) => {\n        // const id = change.doc.id;\n        logger('Anticipating share screen');\n        // Clean up 'screen' session\n        Object.keys(session.current).forEach((key) => {\n          if (session.current[key].type === ConnectType.share) {\n            // session.current[key].listeners.forEach((listener) => listener());\n            // session.current[key].pc.close();\n            // delete session.current[key];\n            deleteSessionByKey(key);\n          }\n        })\n        if (change.type === 'added') {\n          const { offer } = change.doc.data() as Offer;\n          const answerPeer = await createAnswerPeer(callID.current, user.current, 'screen', 'Screen', offer, new MediaStream(), ConnectType.share);\n          // const listener = screenDoc.collection('offerCandidates').doc(user.current).collection('candidates').onSnapshot((ss) => {\n          //   ss.docChanges().forEach(async (cc) => {\n          //     if (cc.type === 'added') {\n          //       let data = cc.doc.data();\n          //       if (answerPeer.pc.signalingState !== 'closed') {\n          //         try {\n          //           await answerPeer.pc.addIceCandidate(new RTCIceCandidate(data));\n          //         }\n          //         catch (error) {\n          //           logger(error);\n          //         }\n          //       }\n          //       else {\n          //         listener();\n          //         deleteSessionByKey('screen');\n          //         deleteSessionByKey('share_to_answer_screen');\n          //         deleteSessionByKey('share_to_offer_screen');\n          //       }\n          //     }\n          //   });\n          // });\n          // answerPeer.listeners.push(listener);\n        }\n      });\n\n      await Promise.all(promises);\n    });\n    globalListeners.current.push(listener);\n  }\n\n  const deletePeerConnection = (key: string, peer: Peer) => {\n    logger(`Connection Disconnected - ${peer.name}`);\n    deleteSessionByKey(key);\n    if (peer.type === ConnectType.user) {\n      fireAlert(`${peer.name} disconnected.`, ALERT_TYPE.info);\n    }\n\n    [\n      `share_to_offer_${peer.peerID}`,\n      // `share_to_offer_screen`,\n      `share_to_answer_${peer.peerID}`,\n      // `share_to_answer_screen`,\n    ].forEach((key) => {\n      deleteSessionByKey(key);\n    });\n  }\n\n  const createAnswerPeer = async (call: string, userID: string, offerID: string, name: string, offer: RTCSessionDescriptionInit, stream: MediaStream, type = ConnectType.user) => {\n    const callDoc = db.collection('calls').doc(call);\n    const userDoc = callDoc.collection('users').doc(offerID);\n    const answers = userDoc.collection('answers').doc(userID);\n    const offerCandidates = userDoc.collection('offerCandidates').doc(offerID).collection('candidates');\n    const answerCandidates = userDoc.collection('answerCandidates').doc(userID).collection('candidates');\n\n    const sessionKey = type === ConnectType.user ? offerID : `share_to_answer_${offerID}`;\n\n    const peer: Peer = {\n      name,\n      peerID: sessionKey,\n      pc: new RTCPeerConnection(config.servers),\n      remoteStream: new MediaStream(),\n      listeners: [],\n      type\n    };\n\n    // Handle Ice Candidate\n    peer.pc.onicecandidate = (e) => {\n      e.candidate && answerCandidates.add(e.candidate.toJSON());\n    }\n    // Push stream from local to remote\n    stream.getTracks().forEach((track) => {\n      peer.pc.addTrack(track, stream);\n    });\n    // Handle Remote Stream\n    peer.pc.ontrack = (e) => {\n      e.streams.forEach((stream) => {\n        stream.getTracks().forEach((track) => {\n          peer.remoteStream.addTrack(track)     \n        })\n      });\n    }\n    // Handle disconnect\n    peer.pc.onconnectionstatechange = (e) => {\n      switch (peer.pc.connectionState) {\n        case \"disconnected\":\n          {\n            deletePeerConnection(sessionKey, peer);\n            break;\n          }\n        case \"closed\":\n          { \n            deletePeerConnection(sessionKey, peer);\n            break;\n          }\n        case \"failed\":\n          { \n            deletePeerConnection(sessionKey, peer);\n            break;\n          }\n      }\n    }\n\n    await peer.pc.setRemoteDescription(new RTCSessionDescription(offer));\n    const answerDescription = await peer.pc.createAnswer();\n    if (peer.type === 'share') {\n      if (answerDescription.sdp) {\n        answerDescription.sdp.replace('useinbandfec=1', 'useinbandfec=1; stereo=1; maxaveragebitrate=510000');\n      }\n    }\n    await peer.pc.setLocalDescription(answerDescription);\n    const answer: RTCSessionDescriptionInit = {\n      sdp: answerDescription.sdp,\n      type: answerDescription.type\n    };\n    await answers.set({ answer });\n\n    // Handle when offerers provide answer candidates\n    const listener = offerCandidates.onSnapshot(async (snapshot) => {\n      snapshot.docChanges().forEach(async (change) => {\n        if (change.type === 'added') {\n          let data = change.doc.data();\n          if (peer.pc.signalingState !== 'closed') {\n            try {\n              await peer.pc.addIceCandidate(new RTCIceCandidate(data));\n            }\n            catch (error) {\n              logger(error);\n            }\n          }\n          else {\n            const sessionKey = peer.type === ConnectType.user ? offerID : `share_to_answer_${offerID}`;\n            deleteSessionByKey(sessionKey);\n            // delete session.current[sessionKey];\n          }\n        }\n      })\n    });\n    peer.listeners.push(listener);\n\n    addToSession(sessionKey, peer);\n\n    if (offerID !== userID) {\n      createVideoComponent(peer, type);\n    }\n    return peer;\n  }\n\n  const handleAnswer = async () => {\n    logger(`Call ID: ${callID.current}`);\n    // Add yourself to the list of uers\n    const callDoc = db.collection('calls').doc(callID.current);\n    const testCall = await callDoc.get();\n    if (!testCall.exists) {\n      fireAlert('Invalid Call ID. Please try again with a valid one.', ALERT_TYPE.error);\n      return;\n    }\n\n    const userDoc = callDoc.collection('users').doc(user.current);\n    await userDoc.set({ name: userName.current, type: ConnectType.user, time: new Date(), status: 'active', mute: mute });\n    const usersCollection = callDoc.collection('users');\n    const screenDoc = callDoc.collection('users').doc('screen');\n\n    // Go through all existing users and connect to them using their offer for your user ID\n    const promises = (await usersCollection.get()).docs\n      .filter((u) => u.id !== user.current)\n      .map(async (doc) => {\n        const id = doc.id;\n        const u = doc.data() as User;\n\n        doc.ref.collection('offers').doc(user.current).onSnapshot(async (snapshot) => {\n          if (snapshot.exists) {\n            if (u.type !== ConnectType.share) {\n              logger(`Retrieving offers from ${id} -- ${u.name}`);\n              const { offer } = snapshot.data() as Offer;\n              const answerPeer = await createAnswerPeer(callID.current, user.current, id, u.name, offer, localStream.current);\n\n              // const listener = doc.ref.collection('offerCandidates').doc(user.current).collection('candidates').onSnapshot((snapshot) => {\n              //   snapshot.docChanges().forEach(async (change) => {\n              //     if (change.type === 'added') {\n              //       let data = change.doc.data();\n              //       if (answerPeer.pc.signalingState !== 'closed') {\n              //         try {\n              //           await answerPeer.pc.addIceCandidate(new RTCIceCandidate(data));\n              //         }\n              //         catch (error) {\n              //           logger(error);\n              //         }\n              //       }\n              //       else {\n              //         listener();\n              //         const sessionKey = answerPeer.type === ConnectType.user ? id : `share_to_answer_${id}`;\n              //         deleteSessionByKey(sessionKey);\n              //         // delete session.current[sessionKey];\n              //       }\n              //     }\n              //   });\n              // });\n              // answerPeer.listeners.push(listener);\n            }\n          }\n        })\n      });\n    await Promise.all(promises);\n\n    // Watch for new users to come in and create new peer connection\n    let listener = usersCollection.onSnapshot(async (snapshot) => {\n      if (Object.keys(session.current).length > 0) {\n        const promises = snapshot.docChanges()\n          .filter((change) => user.current !== change.doc.id)\n          .map(async (change) => {\n            if (change.type === 'added') {\n              const existingUserID = change.doc.id;\n              if (!session.current[existingUserID]) {\n                const u = change.doc.data();\n                if (u.type === ConnectType.user) {\n                  logger(`User ${u.name} joined the call`);\n                  fireAlert(`User ${u.name} joined the call`, ALERT_TYPE.success);\n                  await createOfferPeer(callID.current, user.current, existingUserID, u.name, localStream.current);\n\n                  // If sharing, then create offer for share stream too\n                  const sharingCondition = Object.keys(session.current).reduce((accumulator: boolean, currrentValue: string) => {\n                    if (currrentValue.indexOf('share_to_offer') !== -1) {\n                      return accumulator || true;\n                    }\n                    return accumulator;\n                  }, false);\n                  if (sharingCondition) {\n                    await createOfferPeer(callID.current, 'screen', existingUserID, u.name, shareStream.current, ConnectType.share);\n                  }\n                }\n                else if (u.type === ConnectType.share) {\n                  if (u.shareID !== user.current) {\n                    logger(`User ${u.shareUserName} is sharing their screen`);\n                    fireAlert(`User ${u.shareUserName} is sharing their screen`, ALERT_TYPE.success);\n                    // Close your sharing if exist\n                    shareStream.current.getTracks().forEach((track) => track.stop());\n                  }\n                  else {\n                    logger(`You are sharing your screen`);\n                    fireAlert(`You are sharing your screen`, ALERT_TYPE.success);\n                  }\n                }\n              }\n            }\n          });\n      \n        await Promise.all(promises);\n      }\n    });\n    globalListeners.current.push(listener);\n\n    // Socket to monitor who will share screen\n    listener = screenDoc.collection('offers').onSnapshot(async (snapshot) => {\n      const promises = snapshot.docChanges()\n        .filter((change) => change.doc.id === user.current)\n        .map(async (change) => {\n        // const id = change.doc.id;\n        logger('Anticipating share screen');\n        // Clean up 'screen' session\n        Object.keys(session.current).forEach((key) => {\n          if (session.current[key].type === ConnectType.share) {\n            // session.current[key].listeners.forEach((listener) => listener());\n            // session.current[key].pc.close();\n            // delete session.current[key];\n            deleteSessionByKey(key);\n          }\n        })\n        if (change.type === 'added') {\n          const { offer } = change.doc.data() as Offer;\n          const answerPeer = await createAnswerPeer(callID.current, user.current, 'screen', 'Screen', offer, new MediaStream(), ConnectType.share);\n          const listener = screenDoc.collection('offerCandidates').doc(user.current).collection('candidates').onSnapshot((ss) => {\n            ss.docChanges().forEach(async (cc) => {\n              if (cc.type === 'added') {\n                let data = cc.doc.data();\n                if (answerPeer.pc.signalingState !== 'closed') {\n                  try {\n                    await answerPeer.pc.addIceCandidate(new RTCIceCandidate(data));\n                  }\n                  catch (error) {\n                    logger(error);\n                  }\n                }\n                else {\n                  listener();\n                  deleteSessionByKey('screen');\n                  deleteSessionByKey('share_to_answer_screen');\n                  deleteSessionByKey('share_to_offer_screen');\n                }\n              }\n            });\n          });\n          answerPeer.listeners.push(listener);\n        }\n      });\n\n      await Promise.all(promises);\n    });\n    globalListeners.current.push(listener);\n  }\n\n  const handleShareScreen = async () => {\n    if (Object.keys(session.current).length === 0) {\n      fireAlert('Cannot share screen in empty room. Please wait for more folks to join.', ALERT_TYPE.info);\n      return;\n    }\n\n    // Turn on sharing screen view\n    setIsSharing(true);\n\n    try {\n      shareStream.current.getTracks().forEach((track) => track.stop());\n\n      const castDevices = navigator.mediaDevices as CastDevices;\n      shareStream.current = await castDevices.getDisplayMedia({\n        audio: {\n          echoCancellation: false,\n          autoGainControl: false,\n          noiseSuppression: false,\n          latency: 0,\n          channelCount: 2,\n          sampleRate: 48000,\n          sampleSize: 16\n        },\n        video: {\n          frameRate: 60\n        }\n      });\n      shareVideo.current!.muted = false;\n      shareVideo.current!.volume = 0;\n      shareVideo.current!.srcObject = shareStream.current;\n\n      const callDoc = db.collection('calls').doc(callID.current);\n      const userDoc = callDoc.collection('users').doc(`screen`);\n\n      // Clean up 'screen' session\n      Object.keys(session.current).forEach((key) => {\n        if (session.current[key].type === ConnectType.share) {\n          deleteSessionByKey(key);\n          // session.current[key].listeners.forEach((listener) => listener());\n          // session.current[key].pc.close();\n          // delete session.current[key];\n        }\n      })\n\n      // Delete Screen record. Will need to move to cloud function later\n      const _offers = await userDoc.collection('offers').get();\n      _offers.docs.forEach((_offer) => _offer.ref.delete());\n      const _offerCandidates = await userDoc.collection('offerCandidates').get();\n      let _ps = _offerCandidates.docs.map(async (_offerCandidate) => {\n        const candidates = await _offerCandidate.ref.collection('candidates').get();\n        candidates.forEach((candidate) => candidate.ref.delete());\n      });\n      await Promise.all(_ps);\n      const _answers = await userDoc.collection('answers').get();\n      _answers.docs.forEach((_answer) => _answer.ref.delete());\n      const _answerCandidates = await userDoc.collection('answerCandidates').get();\n      _ps = _answerCandidates.docs.map(async (_answerCandidate) => {\n        const candidates = await _answerCandidate.ref.collection('candidates').get();\n        candidates.forEach((candidate) => candidate.ref.delete());\n      });\n      await Promise.all(_ps);\n      await userDoc.delete();\n\n      // Update screen user\n      await userDoc.set({ name: 'Screen Share', type: ConnectType.share, shareID: user.current, shareUserName: userName.current, time: new Date(), status: 'active', mute: false });\n\n      // Create offers and candidates for each user\n      // const promises = (await callDoc.collection('users').get()).docs\n      //   .filter((doc) => user.current !== doc.id && doc.data().type !== ConnectType.share)\n      //   .map(async (doc) => {\n      //   const existingUserID = doc.id;\n      //   const data = doc.data() as User;\n      //   await createOfferPeer(callID.current, 'screen', existingUserID, data.name, shareStream.current, ConnectType.share);\n      // });\n      // await Promise.all(promises);\n      Object.values(session.current)\n        .filter((peer) => peer.type !== ConnectType.share && user.current !== peer.peerID)\n        .forEach((peer) => {\n          createOfferPeer(callID.current, 'screen', peer.peerID, peer.name, shareStream.current, ConnectType.share);\n        })\n\n      // Analytics\n      analytics.logEvent('share_screen', {\n        name: userName.current,\n        callID: callID.current,\n        userID: user.current\n      });\n      // Socket to create new peers for sharing when new user join in as well\n      // Clear current listener so we don't pile on them\n      // shareUserListener.current();\n      // const usersCollection = callDoc.collection('users');\n      // shareUserListener.current = usersCollection.onSnapshot(async (snapshot) => {\n      //   const ps = snapshot.docChanges()\n      //     .filter((change) => !session.current[change.doc.id] && change.doc.id !== user.current && change.doc.data().type !== ConnectType.share)\n      //     .map(async (change) => {\n      //       if (change.type === 'added') {\n      //           const newUserID = change.doc.id;\n      //           const data = change.doc.data() as User;\n      //           await createOfferPeer(callID.current, 'screen', newUserID, data.name, shareStream.current, ConnectType.share);\n      //       }\n      //     });\n\n      //   await Promise.all(ps);\n      // });\n    }\n    catch (error) {\n      logger(error);\n      fireAlert('Failed to share screen. Please rejoin and try again.', ALERT_TYPE.error);\n      setIsSharing(false);\n    }\n  }\n\n  const handleRoomID = () => {\n    if (clipboardRef.current) {\n      if (clipboardRef.current.value.length > 0) {\n        clipboardRef.current.select();\n        document.execCommand('copy');\n        fireAlert(`Call ID copied into clipboard.`, ALERT_TYPE.info);\n      }\n    }\n  }\n\n  const handleMute = async () => {\n    localStream.current.getAudioTracks().forEach((track) => track.enabled = mute);\n\n    await db.collection('calls').doc(callID.current).collection('users').doc(user.current).update({ mute: !mute });\n    setMute(!mute);\n  }\n\n  const handleEndCall = () => {\n    shareStream.current.getTracks().forEach((track) => track.stop());\n    localStream.current.getTracks().forEach((track) => track.stop());\n\n    Object.keys(session.current).forEach((key) => {\n      deleteSessionByKey(key);\n    });\n    globalListeners.current.forEach((listener) => listener());\n\n    // Analytics\n    analytics.logEvent('end_call', {\n      name: userName.current,\n      callID: callID.current,\n      userID: user.current\n    });\n\n    fireAlert('Ending call...', ALERT_TYPE.info);\n    setTimeout(() => {\n      history.push(ROUTES.JOIN);\n    }, 2000);\n  };\n\n  const toggleWebcam = async () => {\n    if (!webcam) {\n      localStream.current.getVideoTracks().forEach((videoTrack) => videoTrack.enabled = true);\n      localVideo.current!.srcObject = localStream.current;\n    }\n    else {\n      localStream.current.getVideoTracks().forEach((videoTrack) => videoTrack.enabled = false);\n      localVideo.current!.srcObject = null;\n    }\n\n    setWebcam(!webcam);\n  }\n\n  return (\n    <>\n      <div id=\"roomContainer\" className={isSharing ? 'sharing' : 'standalone'}>\n        {\n          isSharing\n          ? (\n            <div id='shareContainer' ref={shareContainer}>\n              <div className=\"videos\">\n                <span>\n                  <video id=\"shareVideo\" ref={shareVideo} autoPlay playsInline muted></video>\n                </span>\n              </div>\n              <ActionButtons\n                shareVideoRef={shareVideo}\n                handleRoomID={handleRoomID}\n                handleShareScreen={handleShareScreen}\n                handleEndCall={handleEndCall}\n              />\n            </div>\n          )\n          : ''\n        }\n        <div ref={videoContainer} id='videoContainer'>\n          {\n            Object.values(\n              sessionState\n            )\n              .filter((peer) => peer.peerID !== user.current && peer.type !== ConnectType.share)\n              .map((peer) => <Video key={peer.peerID} peer={peer} callID={callID.current} />)\n          }\n\n          {/* <Video peer={{\n            name: 'Dummy 1',\n            peerID: '12',\n            pc: new RTCPeerConnection(config.servers),\n            remoteStream: new MediaStream(),\n            listeners: [],\n            type: ConnectType.user\n          }} callID={''} /> */}\n\n          {/* <Video peer={{\n            name: 'Dummy 2',\n            peerID: '13',\n            pc: new RTCPeerConnection(config.servers),\n            remoteStream: new MediaStream(),\n            listeners: [],\n            type: ConnectType.user\n          }} callID={''} />\n\n          <Video peer={{\n            name: 'Dummy 2',\n            peerID: '13',\n            pc: new RTCPeerConnection(config.servers),\n            remoteStream: new MediaStream(),\n            listeners: [],\n            type: ConnectType.user\n          }} callID={''} /> */}\n\n          <div className=\"videos\" id='localVideoContainer'>\n            <span>\n              <video id=\"localVideo\" ref={localVideo} autoPlay playsInline poster={`${process.env.PUBLIC_URL}/user_placeholer.`}></video>\n            </span>\n            <div className='name'>\n              <div>\n                {userName.current}\n              </div>\n              <div>\n                <Tooltip title={mute ? 'Unmute' : 'Mute' } placement='top' onClick={handleMute}>\n                  {\n                    mute ? <VolumeOffSharpIcon fontSize='small'/> : <VolumeUpSharpIcon fontSize='small'/>\n                  } \n                </Tooltip>\n              </div>\n            </div>\n            <div className='action'>\n              <Tooltip title={mute ? 'Unmute' : 'Mute' } placement='bottom'>\n                <Fab aria-label='mute_toggle' size='small' onClick={handleMute}>\n                  {\n                    mute ? <VolumeOffSharpIcon fontSize='small'/> : <VolumeUpSharpIcon fontSize='small'/>\n                  }\n                </Fab>\n              </Tooltip>\n              &nbsp;\n              <Tooltip title={webcam ? 'Camera Off' : 'Camera On' } placement='bottom'>\n                <Fab aria-label='webcam_toggle' size='small' onClick={toggleWebcam}>\n                  {\n                    webcam ? <VideocamOffSharpIcon fontSize='small'/> : <VideocamSharpIcon fontSize='small'/>\n                  }\n                </Fab>\n              </Tooltip>\n            </div>\n          </div>\n        </div>\n\n        {\n          !isSharing\n          ? (\n            <div id='standalone_share'>\n              <ActionButtons\n                shareVideoRef={shareVideo}\n                handleRoomID={handleRoomID}\n                handleShareScreen={handleShareScreen}\n                handleEndCall={handleEndCall}\n              />\n            </div>\n          )\n          : ''\n        }\n\n      </div>\n      <input id=\"clipboard\" ref={clipboardRef} value={callID.current} onChange={() => {}}/>\n      <CustomizedAlert duration={5000} openAlert={openAlert} setOpenAlert={setOpenAlert} alertMessage={alertMessage} alertType={alertType}/>\n    </>\n  )\n}"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}